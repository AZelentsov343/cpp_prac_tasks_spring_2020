В этом году была одна большая кр в самом конце, она же - коллоквиум по СП.
Организация как обычно на уровне, условия предельно ясно сформулированы и не меняются во время кр,
тесты подготовлены заранее и вообще тщетщу и шешу есть дело до студентов.

Было 8 задач, условия примерно такие:
Свой код я не прикладываю, так как на отложенном тестировании выяснилось, что он не очень правильный

# 1. Написать функцию, которая принимает вектор по ссылке и число s далее через каждые s элементов
нужно вставить сумму всех предыдущих. В сумме нужно учитывать только те элементы, которые изначально были в векторе.
Hint: Если делать это с помощью std::vector::insert() то будет ТЛ, так как операция вставки линейная.
Простым решением будет создать еще один вектор, записать в него, а потом переписать этот вектор в исходный.
Мб есть лучше.

# 2. Написать шаблонный класс-матрица (в шаблоне кроме типа элементов передаются еще и размерности),
который поддерживает двойную индексацию. То есть чтобы m[1][2] = 3; int a = m[1][2]; работало нормально.
Hint: Вроде как делается через вложенный класс Row, который возвращается при первой индексации,
и уже из него возращается ссылка на элемент матрицы при второй индексации, но у меня это почему-то упало.
Мб потому что я дурной

# 3. Написать функцию calc_binom, которая принимает три аргумента: числа n и k и std::function, который принимает int.
Нужно посчитать биномиальный коэффициент C^k_n и вызвать переданный std::function от этого числа.
Нельзя пользоваться return и циклами. Нельзя вызывать никакие другие функции и передавать аргументы по ссылке.
Hint: То есть нужно делать с помощью throw-catch рекурсии.
Обойти вызов другой функции можно с помощью четвертого аргумента, имеющего значение по умолчанию.
Этот аргумент будет флагом того, рекурсивный это вызов или вызов извне.

# 4. Написать иерархию классов, сначала абстрактный класс Figure с методом equals.
Потом его наследники, rectangle и triagle с перегруженными этим методом.
Hint: Метод у наследников тоже должен принимать указатель на объект типа Figure,
то есть прежде чем явно сравнивать, нужно скастить его к нужному типу и вернуть false, если такой каст не получится.

# 5. Что-то на многопоточность, я даже не вникал.

# 6. Определеить, принадлежит ли слово грамматике с помощью ДКА.

# 7. Определить, принадлежит ли слово грамматике с помощью рекурсивного спуска.

# 8. Сгенерировать выражение в ПОЛИЗ, которое даст x^a, зная значение a, a >= 0 и пользуясь только символами 1, x, *
Hint: В условии не будет сказано, но сделать это нужно так, чтобы ПОЛИЗ потом считался максимально эффективным образом,
то есть для a = 5, xxxxx**** не катит, нужно xx*x*x*x*
